# 链表

# 1. 了解链表

## 1.1 链表的基本概念

链表是数据结构中的一种基础结构，它由一系列的节点（Node）组成，每个节点包含两部分信息：数据域和指向下一个节点的指针（或引用）。链表与数组相比，最大的优势是插入和删除操作的效率，尤其是在头部或中间进行插入/删除时，不需要像数组那样移动大量元素。

**链表的基本结构通常包含以下几个概念：**

**节点（Node）**：每个节点存储两部分内容：一个是数据域（Data），存储节点的实际数据；另一个是指针域（Pointer 或 Next），指向下一个节点。

**头节点（Head）**：链表的第一个节点，常常作为访问链表的入口。

**尾节点（Tail）**：链表的最后一个节点，它的指针域指向`null`或`None`，表示链表的结束。

## 1.2 链表的基本操作

### 1.2.1 插入操作

核心：断开旧的链条，使新的节点指向下一个节点，前一个节点指向新的节点。

![image-20250205104708315](https://maximg.maxcosmos.top/2025/image-20250205104708315.png)

- **头插法（Head Insertion）**：将新节点插入到链表的最前面。通过调整头指针，使得新节点成为头节点。

- **尾插法（Tail Insertion）**：将新节点插入到链表的末尾。需要遍历链表找到尾节点，然后插入新节点。

- **中间插入**：将新节点插入到链表中的指定位置。需要先定位到该位置的前一个节点，然后将新节点插入。

**时间复杂度分析：**

如果知道插入位置，可以直接插入，O(1)；但如果需要找到位置，则需要O(n)。

### 1.2.2 删除操作

核心：把将要删除节点的前一个节点指向将要删除节点的下一个节点

![image-20250205104539461](https://maximg.maxcosmos.top/2025/image-20250205104539461.png)

- **删除头节点**：通过更新头指针，使其指向下一个节点。

- **删除尾节点**：需要遍历链表，找到倒数第二个节点，然后让其指针指向`null`。

- **删除指定节点**：遍历链表找到待删除节点的前一个节点，将其指针指向待删除节点的下一个节点。

**时间复杂度分析：**

如果知道删除位置，可以直接删除，O(1)；如果需要定位删除节点，则需要O(n)。

### 1.2.3 查找操作

- **查找指定元素**：从头节点开始，遍历链表，查找与目标元素匹配的节点。

- **查找指定位置的节点**：从头节点开始，按照位置顺序遍历链表，直到找到目标位置的节点。

**时间复杂度分析：**

O(n)，最坏情况下，需要遍历整个链表。

### 1.2.4 更新操作

- **更新节点数据**：直接通过节点访问和修改数据域即可。

**时间复杂度分析：**

O(n)，需要先查找该位置的节点，再更新其值。

## 1.3 链表的优缺点

### 1.3.1 优点

**动态大小**：链表可以根据需要动态扩展，避免了数组大小固定的限制。

**高效的插入/删除操作**：在已知位置的情况下，插入和删除节点的时间复杂度是O(1)，相比数组的O(n)操作要高效得多。

### 1.3.2 缺点

**随机访问困难**：与数组不同，链表无法进行随机访问，必须按顺序遍历，因此访问时间复杂度为O(n)。

**额外的内存开销**：每个节点都需要额外的空间存储指针（尤其是双向链表），因此空间开销较大。

## 1.4 简单链表的实现

```java
class Node {
    int data;
    Node next;
    
    public Node(int data) {
        this.data = data;
        this.next = null;
    }
}

class LinkedList {
    Node head;
    
    public LinkedList() {
        this.head = null;
    }
    
    // 插入头部
    public void insertAtHead(int data) {
        Node newNode = new Node(data);
        newNode.next = head;
        head = newNode;
    }
    
    // 插入尾部
    public void insertAtTail(int data) {
        Node newNode = new Node(data);
        if (head == null) {
            head = newNode;
        } else {
            Node temp = head;
            while (temp.next != null) {
                temp = temp.next;
            }
            temp.next = newNode;
        }
    }
    
    // 删除头部节点
    public void deleteAtHead() {
        if (head != null) {
            head = head.next;
        }
    }
    
    // 打印链表
    public void printList() {
        Node temp = head;
        while (temp != null) {
            System.out.print(temp.data + " ");
            temp = temp.next;
        }
        System.out.println();
    }
}
```



# 2. 链表的分类

**单向链表（Singly Linked List）**：每个节点只包含一个指向下一个节点的指针。遍历链表时只能从头节点向后遍历。

**双向链表（Doubly Linked List）**：每个节点包含两个指针，一个指向下一个节点，一个指向前一个节点。这使得在双向链表中，你可以从任意节点向前或向后遍历。

**循环链表（Circular Linked List）**：链表的尾节点指向头节点，形成一个环形结构。可以是单向循环链表，也可以是双向循环链表。

**双向循环链表**：结合了双向链表和循环链表的特点，既可以向前遍历，也可以向后遍历，并且尾节点指向头节点，头节点指向尾节点。

**跳表（Skip List）**：通过在链表中增加多个层级的“跳跃”指针，加速查找操作，使得查找操作可以达到O(log n)的时间复杂度。

**LRU缓存链表**：利用双向链表和哈希表的结合，实现缓存淘汰算法（Least Recently Used，最少使用）。

# 3. 链表的应用

**队列（Queue）**：链表非常适合用来实现队列，因为队列操作（先进先出）可以通过链表的头尾插入和删除操作高效实现。

**栈（Stack）**：链表同样可以用来实现栈（后进先出），通过头插法和头删除法来实现栈的Push和Pop操作。

**图的邻接表表示**：在图的表示方法中，邻接表通常会使用链表来存储每个节点的邻居节点，方便实现图的遍历操作。